# 인터페이스(Interface) vs 추상 클래스(Abstract Class)
> 객체 지향 프로그래밍에서 중요한 개념인 '추상화(Abstract)' 여기서 인터페이스는 추상 클래스에 포함된 개념인건가?

## 아니다!
인터페이스는 추상 클래스와 별도의 개념이다.
#### 추상화를 통해, 비슷한 목표를 달성하도록 설계 된 개념이다.

* 추상 클래스와 인터페이스 비교 

|      |추상 클래스|인터페이스|
|------|----------|---------|
|키워드| abstract  |interface|
|추상화| O         |O       |
|코드 재사용| O    |O      |
|상속|단일|다중|
|상태|프로퍼티,메소드(초기화 가능) |프로퍼티,메소드(선언만 가능)|
|생성자|O|X|
|접근 지정자|설정 가능|public을 권장|

## 추상화란?
복잡한 현실세계에서 핵심적인 특징이나 개념을 간추려서 표현하는 방식.즉 단순화하고 모델링을 하여 프로그램을 효과적으로 설계 할 수 있다.

#### 왜 하냐?
코드의 재사용성 ,유지보수성 그로인한 코드 가독성을 높일 수 있다!

    * 코드의 재사용성
        - 공통적인 메소드와 프로퍼티를 중복을 줄어서 코드의 가독성 높이고,
        프로그램의 크기를 줄일수있다.
    * 코드의 유지보수성
        - 공통기능이 부모클래스에 정의되어있으므로 무언가 변경을할떄 유지보수가 편하다.


### 상속과 추상화의 차이점
* 상속 : 이미 존재하는 클래스와 메서드를 확장하거나 수정한다는 개념

* 추상화 : 복잡한 시스템을 간단하게 표현하는것에 초점 ,핵심적인 요소만 강조 

## 추상 클래스의 용도
1. 공통된 코드구현을 제공
> 공통 된 로직이나 구현을 여러 하위 클래스에서 공유 해야할때!
2. 상태(Field)를 가질수 있음
> 상태,즉 프로퍼티를 가진값 클래스를 설계할떄
3. 단일상속 제약이 적합한 경우
> 상황에 따라 설계를 단순화하고 명확하게 할수도 있다.
```kotlin
// 추상 클래스 정의
abstract class Shape {
    // 추상 메소드
    abstract fun calculateArea(): Double
    
    // 구현된 메소드
    fun display() {
        println("This is a shape.")
    }
}

// 추상 클래스를 상속받는 하위 클래스
class Circle(val radius: Double) : Shape() {
    override fun calculateArea(): Double {
        return Math.PI * radius * radius
    }
}

```
## 인터페이스의 용도
1. 다중 상속을 지원
> 여러개의 타입을 동시에 지원해야하는 경우!
2. 클래스 계층 구조가 복잡하지 않은경우
> 더 유연하게 타입을 확장할 수 있다.
3. 행동만 정의 하는경우
>  프로퍼티와 메소드를 선언만 가능하다.
4. 클래스와는 독립적으로 타입을 정의할 떄
> 다양한 클래스에 공유 될수 있는 특징!
```kotlin
// 인터페이스 정의
interface Shape {
    // 추상 메소드
    fun calculateArea(): Double
    
    // 프로퍼티 선언 (인터페이스에서는 추상 프로퍼티도 선언 가능)
    var description: String
}

// 인터페이스를 구현하는 클래스
class Circle(val radius: Double) : Shape {
    override fun calculateArea(): Double {
        return Math.PI * radius * radius
    }
    
    // 추가적인 멤버 구현
    override val description: String
        get() = "This is a circle."
}

```

# 결론
- 추상화라는 개념을 이용하여,각 상황에 맞게 인터페이스랑 추상 클래스를 활용하여 설계를 하면 된다. 
- 예를 들어 계층 구조가 복잡한경우 추상화 클래스가 더 낫고, 만약 행위만 가지는 클래스를 설계한다면, 인터페이스가 더 나을수 있다. 